## CollectionsLite

[1. Что такое "коллекция".](#1-Что-такое-коллекция)

[1.1. Перечислите основные методы из интерфейса `java.util.Collection`.](#1-1-Перечислите-основные-методы-из-интерфейса)

[2. Назовите преимущества использования коллекций по сравнению с массивами.](#2-Назовите-преимущества-использования-коллекций-по-сравнению-с-массивами.)

[3. Какие данные могут хранить коллекции?](#3-Какие-данные-могут-хранить-коллекции)

[4. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций `List`, `Set`, `Map`.](#4-Какие-есть-типы-коллекций-Как-они-характеризуются-Расскажите-про-иерархию-коллекций-List-Set-Map.)

[5. Назовите основные классы, которые имплементируют/реализуют интерфейсы `List`, `Set`, `Map`.](#5-Назовите-основные-классы-которые-имплементируют-реализуют-интерфейсы-List-Set-Map.)

[6. В чём отличие `ArrayList` от `LinkedList`?](#6-В-чём-отличие-ArrayList-от-LinkedList?)

[7. В чём отличие `HashSet` от `TreeSet`?](#7-В-чём-отличие-HashSet-от-TreeSet?)

[8. В чём отличие `Set` от `Map`?](#8-В-чём-отличие-Se-tот-Map?)

[9. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?](#9-Как-задается-порядок-следования-объектов-в-коллекции-как-отсортировать-коллекцию?)

[10. Чем отличается `Comparable` от `Comparator`?](#10-Чем-отличается-Comparable-от-Comparator?)

[11. Что такое сортировка по принципу `Natural Order`?](#11-Что-такое-сортировка-по-принципу-Natural-Order?)

[12. Что такое `equals` и `hashcode`?](#12-Что-такое-equals-и-hashcode?)

[13. Какие есть способы перебора всех элементов `List`?](#13-Какие-есть-способы-перебора-всех-элементов-List?)

[14. Расскажите о методах `Map`.](#14-Расскажите-о-методах-Map.)

[15. Расскажите, какие классы реализовывают интерфейс `Map`?](#15-Расскажите-какие-классы-реализовывают-интерфейс-Map?)

[16. Расскажите о методах `map.keySet` и `map.entrySet`? Что такое `Entry`?](#16-Расскажите-о-методах-map.keySet-и-map.entrySet-Что-такое-Entry?)

[17. Что будет если вызвать метод `map.put` несколько раз с одинаковым ключом?](#17-Что-будет-если-вызвать-метод-map.put-несколько-раз-с-одинаковым-ключом?)

[18. Как реализован цикл `foreach`?](#18-Как-реализован-цикл-foreach?)

[19. В чем разница между `Iterator` и `Iterable`?](#19-В-чем-разница-между-Iterator-и-Iterable?)

[20. Как происходит удаление элементов из `ArrayList`?](#20-Как-происходит-удаление-элементов-из-ArrayList?)

[21. Как происходит удаление элементов из `LinkedList`?](#21-Как-происходит-удаление-элементов-из-LinkedList?)

[22. Что такое автоупаковка и распаковка? Зачем они нужны?](#22-Что-такое-автоупаковка-и-распаковка-Зачем-они-нужны?)

[23. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?](#23-В-каком-случае-при-работе-с-упакованными-значениями-может-возникнуть-проблема-с-производительностью?)

[24. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.](#24-Опишите-недостатки-и-преимущества-в-использовании-примитивных-типов-и-классов-оберток.)

[25. Что такое очередь? Расскажите принцип работы и для чего она используется.](#25-Что-такое-очередь-Расскажите-принцип-работы-и-для-чего-она-используется.)

[26. Расскажите про интерфейсы `Queue`, `Deque` и их иерархию.](#26-Расскажите-про-интерфейсы-Queue-Deque-и-их-иерархию.)

[27. В чем отличие метода `poll()` от `remove()`?](#27-В-чем-отличие-метода-poll()-от-remove())

[28. В чем отличие метода `element()` от `peek()`?](#28-В-чем-отличие-метода-element()-от-peek()?)

[29. В чем отличие метода `element()` от `poll()`?](#29-В-чем-отличие-метода-element()-от-poll()?)

[30. Перечислите наиболее часто используемые реализации интерфейса `Queue`.](#30-Перечислите-наиболее-часто-используемые-реализации-интерфейса-Queue.)

[31. Что такое ограниченные и неограниченные очереди?](#31-Что-такое-ограниченные-и-неограниченные-очереди?)

[32. Что такое односторонние и двусторонние очереди?](#32-Что-такое-односторонние-и-двусторонние-очереди?)

[33. В чём отличие `Deque` от `Queue`?](#33-В-чём-отличие-Deque-от-Queue?)

[34. В чём отличие методов `removeLast()` и `pollLast()`?](#34-В-чём-отличие-методов-removeLast()-и-pollLast()?)

[35. Назовите самую распространенную реализацию `Deque`.](#35-Назовите-самую-распространенную-реализацию-Deque.)

## 1. Что такое "коллекция".

Это иерархия интерфейсов и реализаций, которая является частью JDK и позволяет программистам пользоваться большим
количеством структур для хранения набора данных. Java предоставляет различные реализации коллекций, такие как ArrayList,
LinkedList, HashMap, TreeSet и другие. Выбор конкретной коллекции зависит от требований приложения и того, как данные
будут использоваться.

[К оглавлению](#CollectionsLite)

## 1.1. Перечислите основные методы из интерфейса java.util.Collection.

Главным набором методов, который важен при рассмотрении любой коллекции является набор CRUD-операций (create, read,
update, delete). На уровне Collection не существует способа обновить запись в коллекции

- add(Object o) - добавляет элемент в коллекцию.
- iterator() - возвращает итератор для перебора элементов коллекции.
- remove(Object o) - удаляет элемент из коллекции.
- contains(Object o) - проверяет, есть ли элемент в коллекции.
- size() - возвращает количество элементов в коллекции.
- clear() - очищает коллекцию (удаляет все элементы).
- toArray() - возвращает массив, содержащий все элементы коллекции

[К оглавлению](#CollectionsLite)

## 2. Назовите преимущества использования коллекций по сравнению с массивами.

- отсутствует необходимость следить за размерами коллекции (в отличие от массива).
- позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано много
  методов по добавлению, удалению, сортировке элементов и т.п.
- упрощают взаимодействие разных частей программы, т.к. являются универсальным способом хранения и передачи данных.
- если правильно подобрать коллекцию, то можно увеличить производительность программы.

[К оглавлению](#CollectionsLite)

## 3. Какие данные могут хранить коллекции?

Любые ссылочные типы данных.

[К оглавлению](#CollectionsLite)

## 4. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map.

На вершине иерархии Java Collection Framework находятся 2 интерфейса: Collection и Map. Они разделяют все коллекции,
входящие в фреймворк, на 2 части по типу хранения данных: простые последовательные наборы элементов, и набор пар
«ключ-значение».
Интерфейс Collection является базовым для всех коллекций, он расширяет интерфейс Iterable поэтому все объекты коллекций
можно перебирать в улучшенном цикле for. У интерфейса Iterable определен только один метод iterator(). Таким образом все
наследники Collection обязаны вернуть итератор. Итератор – это объект, который абстрагирует
за единым интерфейсом доступ к элементам коллекции. К тому же итератор – это паттерн, который позволяет получить доступ
к элементам любой коллекции без необходимости вникать в суть его реализации.

- List - реализации этого интерфейса представляют собой упорядоченные коллекции. Кроме того, разработчику
  предоставляется возможность доступа к элементам коллекции по индексу и по значению (так как реализации позволяют
  хранить дубликаты, результатом поиска по значению будет первое найденное вхождение).
- Set - множество. Set не допускает хранение двух одинаковых элементов.
- Map - карта, ассоциативный массив (значения хранятся в виде пар ключ-значение. Каждому элементу из множества ключей
  соответствует множество значений. Ключи уникальные. По ключу получаем значение. У мапы нет итератора. Мап не
  наследуется от Collection. У Map есть метод entrySet(), который возвращает Set с Entry-объектами (ключ и
  значение). Можно итерироваться по этому набору и получить доступ к ключу и значению каждой пары.)
- Queue (Deque) - интерфейс описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно —
  очереди FIFO (first-in-first-out).

[К оглавлению](#CollectionsLite)

## 5. Назовите основные классы, которые имплементируют/реализуют интерфейсы List, Set, Map.

- ArrayList, LinkedList, Vector - классы для хранения элементов в виде массива. Они реализуют интерфейс List.
- HashSet, LinkedHashSet, TreeSet - классы для хранения уникальных элементов. Они реализуют интерфейсы Set и SortedSet.
- HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap - классы для хранения пар ключ-значение. Они реализуют интерфейс
  Map и его наследников.

[К оглавлению](#CollectionsLite)

## 6. В чём отличие ArrayList от LinkedList?

Основное отличие между ними заключается в том, как они хранят элементы.

- ArrayList использует массив для хранения элементов, и когда требуется добавить новый элемент, он увеличивает размер
  массива. Это делает добавление элементов быстрым, но удаление элементов из середины списка может быть медленным, так
  как
  необходимо переместить все элементы после удаляемого.

- LinkedList использует связные списки для хранения элементов. Каждый элемент содержит ссылку на следующий и предыдущий
  элементы, что позволяет добавлять и удалять элементы из любого места списка быстро. Однако, поиск элементов может быть
  медленнее, так как требуется пройти по всему списку до нужного элемента.

[К оглавлению](#CollectionsLite)

## 7. В чём отличие HashSet от TreeSet?

TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных
операций в TreeSet lg N. HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что
в HashSet в качестве ключа выступает сам элемент, кроме того HashSet (как и HashMap) не поддерживает упорядоченное
хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap.

[К оглавлению](#CollectionsLite)

## 8. В чём отличие Set от Map?

Set - расширяет интерфейс Collection, Map - не входит в иерархию. Set используется для хранения неупорядоченных
коллекций уникальных элементов, в то время как Map хранит пары
ключ-значение и позволяет быстро извлекать значение по ключу.

[К оглавлению](#CollectionsLite)

## 9. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?

Порядок задается либо естественным следованием элементов (natural order), либо объектом, реализующим интерфейс сравнения
Comparator. Если объекты коллекции поддерживают интерфейс Comparable, то через Collections.sort(collection).
Если нет, то у коллекции вызвать метод sort() и передать ему Comparator в качестве аргумента collection.sort(new
MyComparator()). Либо использовать метод Collections.sort(collection, new MyComparator()).

[К оглавлению](#CollectionsLite)

## 10. Чем отличается Comparable от Comparator?

Comparable - используется только для сравнения объектов класса, в котором данный интерфейс реализован. Т.е. интерфейс
Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации (по правилам
разработчика). Collections.sort(collection);

Comparator - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. Т.е.
интерфейс Comparator позволяет создавать объекты, которые будут управлять процессом сравнения:

- при сортировках в методах Collections.sort(collection, new MyComparator()), Arrays.sort(array, new MyComparator()) или
  collection.sort(new MyComparator())
- при управлении порядком в отсортированных множествах TreeSet или отсортированных картах TreeMap, например new
  TreeSet<T> (new MyComparator()).

Отличия: Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации и, если
нет
доступа к исходникам, ее невозможно изменить.
Comparator позволяет определить логику сравнения объектов определенного ссылочного типа вне реализации этого типа и эту
логику можно в любой момент изменить.
Comparable используется для сортировки по возрастанию, а Comparator для сортировки по убыванию.

[К оглавлению](#CollectionsLite)

## 11. Что такое сортировка по принципу Natural Order?

Значения располагаются от меньшего к большему.

[К оглавлению](#CollectionsLite)

## 12. Что такое equals и hashcode?

Методы, необходимые для определения равенства объектов. Метод equals сравнивает два объекта на равенство. Если результат
сравнения равен true, это означает, что два объекта равны.
Метод hashcode используется для определения местоположения объекта в хэш-таблице. Если два объекта имеют одинаковый
хэш-код, то вызывается метод equals для сравнения двух объектов.
Если не переопределить метод equals, он будет сравнивать ссылки на объекты. Если вы переопределите этот
метод, вы должны также переопределить метод hashCode, чтобы обеспечить корректную работу хэш-таблицы.

[К оглавлению](#CollectionsLite)

## 13. Какие есть способы перебора всех элементов List?

+ **циклы** `for`, `while`, `foreach`

```java
for(int i=0;i<countries.size();i++){
        System.out.println(countries.get(i));
        }
```

```java
int i=0;
        while(i<countries.size()){
        System.out.println(countries.get(i++));
        }
```

```java
for(String country:countries){
        System.out.println(country);
        }    
```

+ **итераторы** `Iterator`, `ListIterator`

```java
Iterator<String> countriesIterator=countries.iterator();
        while(countriesIterator.hasNext()){
        System.out.println(countriesIterator.next());
        }
```

```java
ListIterator<String> listIterator=countries.listIterator();
//в прямом порядке
        while(listIterator.hasNext()){
        System.out.println(listIterator.next());
        }
//в обратном порядке
        while(listIterator.hasPrevious()){
        System.out.println(listIterator.previous());
        }    
```

Если вызвать метод `next()` итератора, указывающего на последний элемент в коллекции,
то возникнет исключение `NoSuchElementException`. Следует это помнить и использовать метод `hasNext()` перед
вызовом `next()`.

[К оглавлению](#CollectionsLite)

## 14. Расскажите о методах Map.

V put(K key, V value); - вставит данные в карту.

keySet(), values() и entrySet() — возвращают соответственно набор ключей, значений и пар ключ-значение в карте.

V get(K key); - получить значение по ключу.

remove(key) — удаляет элемент с указанным ключом из карты. Если ключ отсутствует, исключение не выбрасывается.

containsKey(key) и containsValue(value) — проверяют, содержит ли карта указанный ключ или значение.

clear() — удаляет все элементы из карты.

size() — возвращает количество элементов в карте.

isEmpty() — проверяет, пуста ли карта.

[К оглавлению](#CollectionsLite)

## 15. Расскажите, какие классы реализовывают интерфейс Map?

Наиболее часто используемые реализации интерфейса Map в Java включают HashMap, LinkedHashMap, TreeMap,
ConcurrentHashMap, Hashtable и WeakHashMap.

- HashMap - это хэш-карта, которая использует алгоритм хеширования для быстрого доступа к элементам.
- LinkedHashMap обеспечивает дополнительный порядок элементов, сохраняя ссылки на предыдущие и последующие элементы.
- TreeMap упорядочивает элементы по их ключам, используя красно-черное дерево для хранения элементов.
- ConcurrentHashMap является потокобезопасной версией HashMap, оптимизированной для многопоточных приложений.
- Hashtable - это устаревшая реализация Map, которая все еще используется в некоторых старых приложениях.
- WeakHashMap использует слабые ссылки для хранения элементов, что может быть полезно для приложений, где необходим
  сбор мусора.

[К оглавлению](#CollectionsLite)

## 16. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?

Методы необходимые для итерации по элементам.

- keySet(), возвращает коллекцию java.util.Set состоящую только из ключей.
- entrySet(), вернет коллекцию java.util.Set состоящую из объекта Map.Entry, которая сразу содержит и ключ и значение.
- Entry - это класс в Java, который представляет пару ключ-значение. Он используется для работы с картами и коллекциями.
  Entry имеет методы getKey() и getValue() для получения ключа и значения соответственно.

[К оглавлению](#CollectionsLite)

## 17. Что будет если вызвать метод map.put несколько раз с одинаковым ключом?

В этом случае будет сохраняться последний элемент с данным ключом.

[К оглавлению](#CollectionsLite)

## 18. Как реализован цикл foreach?

Цикл for-each внутри использует механизм итератора. Все
коллекции реализуют шаблон проектирования - итератор. Этот
шаблон позволяет получить все элементы из любой коллекции. Шаблон итератор основан на интерфейсе java.util.Iterable.
Он имеет три основных метода:

- boolean hasNext() - проверяет на наличие следующего элемента в списке.
- T next() - возвращает элемент из коллекции и переводит указатель на следующий элемент.
- void remove() - удаляет элемент из коллекции и переводит указатель назад.

Указатель - это механизм позволяющий извлечь одиночный элемент из коллекции. Например: для массива указатель будет
индекс
элемента.
Цикл foreach в Java не является настоящим циклом, он всего лишь синтаксический сахар для итераторов. Каждый раз, когда
вы используете foreach, Java создает итератор для коллекции и выполняет блок кода для каждого элемента в коллекции.

[К оглавлению](#CollectionsLite)

## 19. В чем разница между Iterator и Iterable?

Interface Iterable находится в пакете java.lang и реализация этого интерфейса позволяет объекту быть итерируемым с
помощью for-each. Из под реализации Iterable можно вызвать метод iterator(). И не один. И даже в нескольких потоках. А
может и не использовать итератор вовсе.

Interface Iterator находится в пакете java.util. В его имплементации задаются правила обхода коллекции.

Iterable (какое) - итерируемое. То по чему можно итерироваться. Реализуется классом, по которому нужно будет
итерироваться.
Iterator (кто/что) - инструмент итерирования по коллекции. Итератор это отдельный класс, как правило, вложенный в
итерируемый класс, который задает логику итерации по итерируемому. И, естественно, реализует интерфейс Iterator.

[К оглавлению](#CollectionsLite)

## 20. Как происходит удаление элементов из ArrayList?

Находится заданный элемент. Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а
значение size уменьшается на 1.

```java
        System.arraycopy(es,i+1,es,i,newSize-i)
        es[size=newSize]=null;
```

[К оглавлению](#CollectionsLite)

## 21. Как происходит удаление элементов из LinkedList?

Заменяются ссылки previous и next у соседних элементов.

[К оглавлению](#CollectionsLite)

## 22. Что такое автоупаковка и распаковка? Зачем они нужны?

Автоупаковка - это автоматическая инкапсуляция примитивного типа в эквивалентную ему класс-обёртку всякий раз, когда
требуется объект данного типа. Происходит:

- при присвоении значения примитивного типа переменной соответствующего класса-обёртки.
- при передаче примитивного типа в параметр метода, ожидающего соответствующий ему класс-обёртку.

Автораспаковка - это преобразование класса-обёртки в соответствующий ему примитивный тип. Если при распаковке
класс-обёртка был равен null, произойдет исключение java.lang.NullPointerException. Происходит:

- при присвоении экземпляра класса-обёртки переменной соответствующего примитивного типа.
- в выражениях, в которых один или оба аргумента являются экземплярами классов-обёрток (кроме операции == и !=).
- при передаче объекта класса-обёртки в метод, ожидающий соответствующий примитивный тип.

Автоупаковка и распаковка очень часто происходит при работе с коллекциями, так как они не могут хранить примитивные типы
данных.

[К оглавлению](#CollectionsLite)

## 23. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?

Появление классов-обёрток обусловлено тем, что Java - это объектно-ориентированный язык, и все сущности в идеале должны
быть объектами. Но отказавшись от примитивных типов, упала бы производительность, поэтому к существующим примитивным
типам добавили соответствующие классы-обертки, тем самым обеспечив гибкость работы с примитивными значениями.
Классы-обертки являются неизменяемыми, поэтому упакованное значение невозможно изменить. Для очень трудоёмких
вычислений, где производительность критически важна, следует использовать примитивные типы.

[К оглавлению](#CollectionsLite)

## 24. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.

- при работе с примитивными типами повышается производительность, так как на упаковку значения в обёртку уходит
  дополнительное время.
- примитивные типы занимают меньше места в памяти.
- если в программе работа идет с объектами, а не со значениями, то работать с примитивными типами будет нельзя,
  понадобится упаковка.
- обёртки - это такие же классы со своими методами, как и любые остальные, которые мы рассматривали. Поэтому работа
  со значением в виде объекта даёт преимущества в виде возможности применения методов этих классов. (Например, для
  Integer это parseInt(), valueOf(), compareTo() и т.д.).

[К оглавлению](#CollectionsLite)

## 25. Что такое очередь? Расскажите принцип работы и для чего она используется.

Очередь используется для вставки элементов в конец очереди и удаления из начала очереди. Такой способ организации
хранения
данных называется FIFO(First-In-First-Out). Очередь – очень удобный инструмент, который используется для моделирования
реальных ситуаций ожидания клиентов в банке,
вылета самолетов или передачи данных по Интернету.

[К оглавлению](#CollectionsLite)

## 26. Расскажите про интерфейсы Queue, Deque и их иерархию.

Queue - это интерфейс, который представляет собой очередь, то есть структуру данных, где элементы добавляются в один
конец и удаляются из другого конца. Он реализует методы add() и remove(), а также contains(Object),
iterator() и size().

Deque (Double-ended queue) - это двунаправленная очередь, которая позволяет добавлять и удалять элементы с обоих концов.
Он расширяет интерфейс Queue и добавляет дополнительные методы, такие как addFirst(), removeFirst(), addLast() и
removeLast().
Иерархия этих интерфейсов выглядит следующим образом:`Collection -> Queue -> Deque`Т.е. Queue является
подклассом интерфейса Collection, а Deque - подклассом Queue.

[К оглавлению](#CollectionsLite)

## 27. В чем отличие метода poll() от remove()?

Методы отличаются когда мы применяем их на пустой очереди. Если мы применим remove() на пустой очереди, то поймаем
исключение NoSuchElementException, если же у пустой очереди вызвать poll(), то метод вернет null.

[К оглавлению](#CollectionsLite)

## 28. В чем отличие метода element() от peek()?

Методы отличаются когда мы применяем их на пустой очереди. Если мы применим element() на пустой очереди, то поймаем
исключение NoSuchElementException, если же у пустой очереди вызвать peek(), то метод вернет null.

[К оглавлению](#CollectionsLite)

## 29. В чем отличие метода element() от poll()?

element() возвращает первый элемент из очереди, без удаления этого элемента, а poll() удаляет первый элемент из очереди.

[К оглавлению](#CollectionsLite)

## 30. Перечислите наиболее часто используемые реализации интерфейса Queue.

LinkedList , ArrayBlockingQueue и PriorityQueue.

[К оглавлению](#CollectionsLite)

## 31. Что такое ограниченные и неограниченные очереди?

Ограниченные очереди имеют максимальный размер, то есть они могут хранить только определенное количество элементов.
Когда очередь достигает своего максимального размера, новые элементы не могут быть добавлены, пока один или несколько
элементов не будут удалены. Это полезно, когда нужно контролировать объем данных, которые могут храниться в очереди.
Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями.

Неограниченные очереди не имеют максимального размера и могут расти до тех пор, пока есть место на жестком диске. Это
может привести к утечке памяти, если не следить за тем, как быстро
растут данные. Очереди, доступные в пакете java.util, являются неограниченными очередями.

[К оглавлению](#CollectionsLite)

## 32. Что такой односторонние и двусторонние очереди?

Односторонняя очередь, это такая очередь, в которую элементы могут быть добавлены\удалены только в одном направлении.
Двухсторонняя очередь, это такая очередь, в которую элементы могут быть добавлены\удалены в двух направлениях.

[К оглавлению](#CollectionsLite)

## 33. В чём отличие Deque от Queue?

В способе добавления\удаления элементов. Queue позволяет добавление и удаление только в одной стороне — в конце. Deque (
double-ended queue, двунаправленная очередь) — это структура данных, в которую можно добавлять и удалять элементы как в
начале, так и в конце очереди.

[К оглавлению](#CollectionsLite)

## 34. В чём отличие методов removeLast() и pollLast()?

Методы удаляют первый элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй –
вернет null.

[К оглавлению](#CollectionsLite)

## 35. Назовите самую распространенную реализацию Deque.

LinkedList.

[К оглавлению](#CollectionsLite)