## OOP

[1. Что такое ООП?](#1-Что-такое-ООП)

[2. Базовые концепции ООП?](#2-Базовые-концепции-ООП)

[3. Укажите из каких элементов состоит класс?](#3-Укажите-из-каких-элементов-состоит-класс-расскажите-о-каждом-из-них)

[4. Что такое конструктор? Типы конструкторов?](#4-Что-такое-конструктор)

[5. Можно ли наследовать конструктор?](#5-Можно-ли-наследовать-конструктор)

[6. Что такое перегрузка конструктора?](#6-Что-такое-перегрузка-конструктора)

[7. Что такое статический метод?](#7-Что-такое-статический-метод)

[8. Что такое не статический метод?](#8-Что-такое-не-статический-метод)

[9. Для чего используется ключевое слово this?](#9-Для-чего-используется-ключевое-слово-this)

[10. Какой класс является базовый родительным классов для всех классов?](#10-Какой-класс-является-базовым-родительским-классом-для-всех-классов)

[11. Что такое наследование? Приведите примеры из реальной жизни.](#11-Что-такое-наследование-Приведите-примеры-из-реальной-жизни)

[12. Опишите процесс создания нового объекта.](#12-Опишите-процесс-создания-нового-объекта)

[13. Как вызвать метод из родительского класса?](#13-Как-вызвать-метод-из-родительского-класса)

[14. Что такое переопределение метода?](#14-Что-такое-переопределение-метода)

[15. Можно ли переопределить статический метод?](#15-Можно-ли-переопределить-статический-метод)

[16. Что такое сокрытие метода?](#16-Что-такое-сокрытие-метода)

[17. Что такое виртуальная функция и используются ли они в Java?](#17-Что-такое-виртуальная-функция-и-используются-ли-они-в-Java)

[18. Что такое перегрузка метода?](#18-Что-такое-перегрузка-метода)

[19. Можно ли изменить тип возвращаемых данных при перегрузке метода?](#19-Можно-ли-изменить-тип-возвращаемых-данных-при-перегрузке-метода)

[20. Что такое множественное наследование? Как его можно реализовать в Java.](#20-Что-такое-множественное-наследование-Как-его-можно-реализовать-в-Java)

[21. Что такое полиморфизм? Приведите примеры из реальной жизни.](#21-Что-такое-полиморфизм-приведите-примеры-из-реальной-жизни)

[22. Что такое инкапсуляция?](#22-Что-такое-инкапсуляция)

[23. Как реализована инкапсуляция в Java? ](#23-Как-реализована-инкапсуляция-в-Java)

[24. Можно ли применить модификаторы доступа к конструкторам?](#24-Можно-ли-применить-модификаторы-доступа-к-конструкторам)

[25. Что такое интерфейс?](#25-Что-такое-интерфейс)

[26. Перечислите элементы, которые может содержать интерфейс.](#26-Перечислите-элементы-которые-может-содержать-интерфейс)

[27. Можно ли создать объект интерфейса? Если да, то как?](#27-можно-ли-создать-объект-интерфейса-если-да-то-как)

[28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?](#28-может-ли-интерфейс-содержать-какие-либо-методы-с-реализацией-если-да-то-какие)

[29. Что такое абстракция?](#29-Что-такое-абстракция)

[30. Что такое абстрактный класс?](#30-Что-такое-абстрактный-класс)

[31. Сколько абстрактных методов должен и может содержать абстрактный класс?](#31-Сколько-абстрактных-методов-должен-и-может-содержать-абстрактный-класс)

[32. Может ли абстрактный класс содержать обычные методы?](#32-Может-ли-абстрактный-класс-содержать-обычные-методы)

[33. Сколько объектов абстрактного класса можно создать в программе?](#33-Сколько-объектов-абстрактного-класса-можно-создать-в-программе)

[34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?](#34-Что-нужно-делать-если-наследник-абстрактного-класса-не-переопределяет-все-абстрактные-методы-родителя)

[35. Чем отличается интерфейс от абстрактного класса?](#35-Чем-отличается-интерфейс-от-абстрактного-класса)

[36. Что такое вложенные классы? Зачем они нужны?](#36-Что-такое-вложенные-классы-Зачем-они-нужны)

[37. Какие типы вложенных классов существуют в Java?](#37-Какие-типы-вложенных-классов-существуют-в-Java)

[38. Что такое внутренний класс? Когда он применяется?](#38-Что-такое-внутренний-класс-Когда-он-применяется)

[39. Что такое статический вложенный класс? Когда он применяется?](#39-Что-такое-статический-вложенный-класс-Когда-он-применяется)

[40. Сколько объектов статического вложенного класса можно создать в программе?](#40-Сколько-объектов-статического-вложенного-класса-можно-создать-в-программе)

[41. Что такое локальный класс? Когда он применяется?](#41-Что-такое-локальный-класс-Когда-он-применяется)

[42. Что такое анонимный класс? Когда он применяется?](#42-Что-такое-анонимный-класс-Когда-он-применяется)

[43. Сколько объектов анонимного класса можно создать в программе?](#43-Сколько-объектов-анонимного-класса-можно-создать-в-программе)

[44. Что такое исключения? Какие типы исключительных ситуаций бывают?](#44-Что-такое-исключения-Какие-типы-исключительных-ситуаций-бывают)

[45. Назовите основные методы класса Object?](#45-Назовите-основные-методы-класса-Object)

[46. Что такое шаблоны проектирования?](#46-Что-такое-шаблоны-проектирования)

[47. Объясните шаблон - декоратор. Придумайте пример, не относящийся к технике.](#47-Объясните-шаблон-декоратор-Придумайте-пример-не-относящийся-к-технике)

[48. Объясните шаблон - стратегия. Придумайте пример, не относящийся к технике.](#48-Объясните-шаблон-стратегия-Придумайте-пример-не-относящийся-к-технике)

[49. Объясните шаблон - синглтон. Придумайте пример, не относящийся к технике.](#49-Объясните-шаблон-синглтон-Придумайте-пример-не-относящийся-к-технике)

[50. Объясните шаблон - фабричный метод. Придумайте пример, не относящийся к технике.](#50-Объясните-шаблон-фабричный-метод-Придумайте-пример-не-относящийся-к-технике)

[51. Что такое enum? Когда можно его применять?](#51-Что-такое-enum-Когда-можно-его-применять)

[52. Что такое record? Когда можно его применять?](#52-Что-такое-record-Когда-можно-его-применять)

[53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?](#53-Зачем-нужны-StringBuilder-StringBuffer-StringJoiner-Что-они-делают)

[54. Чем отличаются StringBuffer и StringBuilder?](#54-Чем-отличаются-StringBuffer-и-StringBuilder)

[55. Каким образом производится экранирование символов и зачем это нужно?](#55-Каким-образом-производится-экранирование-символов-и-зачем-это-нужно)

[56. Что такое управляющие последовательности?](#56-Что-такое-управляющие-последовательности)

[57. Зачем нужно форматирование данных? Метод format()](#57-зачем-нужно-форматирование-данных-метод-format)

[58. Что такое varargs? В каких случаях стоит его применять?](#58-Что-такое-varargs-В-каких-случаях-стоит-его-применять)

[59. В каких случаях может возникнуть неоднозначность при работе с varargs?](#59-В-каких-случаях-может-возникнуть-неоднозначность-при-работе-с-varargs)

[60. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?](#60-Что-такое-форматированный-вывод-какие-механизмы-позволяют-осуществить-форматированный-вывод)

## 1. Что такое ООП?

Объектно ориентированное программирование - это методология программирования, в которой приложения состоят из
взаимодействующих между собой объектов, каждый из которых является экземпляром определенного класса, а классы образуют
иерархию наследования.
ООП разработано так, что бы упростить расширение программ и их поддержку.
ООП программу можно охарактеризовать, как данные, управляющие доступом к коду.

Минусы ООП:

+ идеи ООП сложны для понимания.
+ требуется больше памяти, тк программа состоит из классов, методов, интерфейсов.
+ необходим большой набор первоначальных знаний, для того, что бы что-то написать.
+ большие временные затраты на первоначальный анализ.

Плюсы ООП:

+ легко читается – не нужно выискивать в коде функции и выяснять, за что они отвечают.
+ быстро пишется – можно быстро создать сущности, с которыми должна работать программа.
+ простота реализации большого функционала – т. к. на написание кода уходит меньше времени, можно гораздо быстрее
  создать приложение с множеством возможностей.

[К оглавлению](#OOP)

## 2. Базовые концепции ООП?

+ **Абстракция** - это модель некоего объекта или явления реального мира, откидывающая незначимые детали, не играющие
  существенной роли в данном контексте, т.е. она позволяет при работе с объектом не задумываться о его внутренней
  реализации, так же как и в жизни мы не задумываемся какие процессы происходят в телефоне, когда мы им пользуемся.
+ **Полиморфизм** - способность программы выбирать различные реализации, при вызове операций с одним и тем же названием.
  Полиморфизм в java достигается за счет использования интерфейсов.
+ **Инкапсуляция** - это способность объектов скрывать часть своего состояния и поведения от других объектов,
  предоставляя внешнему миру только интерфейс взаимодействия с собой.
+ **Наследование** - это возможность создания новых классов на основе существующих. Главная польза наследования -
  повторное использование существующего кода. Расплата за наследование проявляется в том, что подклассы всегда следуют
  интерфейсу родительского класса, мы не можем исключить из подкласса метод, объявленный в его родителе.

[К оглавлению](#OOP)

## 3. Укажите из каких элементов состоит класс. Расскажите о каждом из них.

Класс - это своеобразный шаблон, по которому создаются объекты. Класс - логическая конструкция, объект - физическое
воплощение. Например: форма для запекания леденцов - класс, леденец, который мы изготовили из этой формы - объект. Класс
состоит из:

+ полей(переменных), то что объект про себя знает.
+ методов(функции для работы с полями), то что объект умеет делать.
+ конструкторов, для инициализации объектов.

Переменные бывают:

+ локальные переменные. Объявляются внутри методов. Уничтожаются по завершении работы метода, в котором объявлены.
+ переменные экземпляра. Доступны в пределах класса, из любого метода или иных блоков кода конкретного класса.
+ статические переменные. Такие переменные привязаны к классу, а не к объекту.

[К оглавлению](#OOP)

## 4. Что такое конструктор?

**Конструктор** — это специальный метод, который вызывается при создании нового объекта (всегда вызывается совместно с
операцией `new`). Конструктор служит для автоматической инициализации переменных, т.е. он инициализирует объект
непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису
конструктор похож на метод без возвращаемого значения `void`.

Виды конструкторов:

+ конструктор по умолчанию или неявный (без параметров - позволяет регулировать, какие параметры и в каком количестве
  нужно задать для создания объекта определенного класса).
+ конструктор с параметрами или явный.

[К оглавлению](#OOP)

## 5. Можно ли наследовать конструктор?

Конструктор не является полем класса, поэтому его нельзя наследовать, но его можно вызвать с помощью ключевого
слова `super`. Если в наследнике не указан конструктор, то конструктор по умолчанию вызывает конструктор по умолчанию
своего родителя.

[К оглавлению](#OOP)

## 6. Что такое перегрузка конструктора?

**Перегрузка конструктора** - это создание конструкторов с другим набором аргументов (как по количеству, так и по
порядку следования). Перегрузка конструктора позволяет установить различные способы начальной инициализации объектов
класса. Если был создан конструктор, принимающий аргументы, а нам нужен конструктор по умолчанию (без аргументов), то
его нужно создать явно.

[К оглавлению](#OOP)

## 7. Что такое статический метод?

**Статический метод** - это метод, который может быть вызван без создания экземпляра класса. Статические методы доступны
через класс, а не через экземпляр класса. Статические методы могут ссылаться только на статические переменные. Это
гарантирует, что во время выполнения нашего метода все элементы будут инициализированы и будут работать. Это
называется "статическим контекстом".

[К оглавлению](#OOP)

## 8. Что такое не статический метод?

**Не статический метод** - это метод, для работы которого необходим объект. Т.е. он принадлежит объекту класса и
может быть вызван с помощью ссылки на данный объект. Не статические методы могут обращаться к полям класса, к
статическим так и не статическим.

[К оглавлению](#OOP)

## 9. Для чего используется ключевое слово this?

Ключевое слово `this` используется в Java для указания на текущий экземпляр объекта. Например, если мы хотим обратиться
к полю или методу текущего объекта внутри метода, мы можем использовать `this`.

`this` используется:

+ в теле любого метода для ссылки на текущий объект, чтобы обращаться к полям и методам данного класса.
  Например, когда у переменной экземпляра и переменной метода\конструктора одинаковые имена.

+ когда нужно вызвать один конструктор из другого (например, конструктор по умолчанию вызывается в параметризованном).
  Вызов `this` может находиться только в первой строке конструктора.

[К оглавлению](#OOP)

## 10. Какой класс является базовым родительским классом для всех классов?

`Object` - корневой класс в иерархии классов Java. Все не примитивные типы, включая массивы, наследуют прямо или
косвенно от него. Поэтому ссылочная переменная класса `Object` может ссылаться на объект любого другого класса. Ключевое
слово `super` представляет текущий экземпляр родительского класса.

[К оглавлению](#OOP)

## 11. Что такое наследование? Приведите примеры из реальной жизни.

Наследование - это возможность создания новых классов на основе существующих. Главная польза наследования - повторное
использование существующего кода. Расплата за наследование проявляется в том, что подклассы всегда следуют интерфейсу
родительского класса, мы не можем исключить из подкласса метод, объявленный в его родителе. Например: класс автомобиль.
На основе его можно создать дочерние классы - седан, хэтчбек, кабриолет. Дочерние классы были созданы на базе класса
автомобиль, они обладают всеми свойствами класса автомобиль, но так же имеют свои уникальные особенности, такие как
разный внешний вид.

[К оглавлению](#OOP)

## 12. Опишите процесс создания нового объекта.

Объект создается с помощью ключевого слова `new`, которое резервирует кусок памяти, записывает в нее данные объекта,
вызывает конструктор класса, который инициализирует начальное состояние объекта.

[К оглавлению](#OOP)

## 13. Как вызвать метод из родительского класса?

Если метод родительского класса переопределен, а нужно вызвать оригинальную версию метода, то нужно использовать
ключевое слово super, которое представляет текущий экземпляр родительского класса.

[К оглавлению](#OOP)

## 14. Что такое переопределение метода?

Переопределение метода - это механизм, который позволяет подклассу изменять реализацию метода, определенного в
суперклассе. Это позволяет подклассу контролировать поведение метода, не изменяя его сигнатуру или имя. Имя метода,
порядок параметров, параметры, тип возвращаемого значения должны совпадать с базовым классом. IDEA позволяет с помощью
аннотации `@Override` проверить правильность кода на стадии его компиляции. Этим уменьшает возникновение
непредвиденных ошибок. Переопределять можно только нестатические методы. Если же попытаемся переопределить
статический метод, это будет называться "сокрытием метода из суперкласса".

[К оглавлению](#OOP)

## 15. Можно ли переопределить статический метод?

Нет, нельзя переопределить статический метод в Java. Переопределение методов возможно только для нестатических методов.
Статические методы связаны с классом, а не с экземпляром класса, поэтому они не могут быть переопределены.

[К оглавлению](#OOP)

## 16. Что такое сокрытие метода?

Сокрытие метода - это когда дочерний класс определяет статический метод с такой же сигнатурой, что содержится в
родительском классе. Статические методы можно наследовать, но переопределить их нельзя. Обычный статический метод может
быть вызван из своего класса, аналогично скрытый статический метод также вызывается из своего класса. Если в дочернем
классе требуется изменить статический метод из родительского класса, это называется "Сокрытием статического метода" в
отличие от "переопределения" для нестатического метода `@overriding`. Во время компиляции статические методы связаны с
типом объявленной переменной, то есть какой класс объявлен в типе, статический метод того класса и будет вызван.

[К оглавлению](#OOP)

## 17. Что такое виртуальная функция и используются ли они в Java?

Виртуальная функция - это функция (метод), которая может быть переопределена наследником. То есть почти все
нестатические методы Java - это виртуальные функции (кроме private-методов, так как они не могут быть переопределены в
связи с правами видимости). Статические методы принадлежат классу и не могут быть переопределены, поэтому они не
являются виртуальными функциями.

[К оглавлению](#OOP)

## 18. Что такое перегрузка метода?

Это механизм позволяющий создавать методы с одинаковыми именами, но разными входными параметрами. При вызове
перегруженного метода компилятор автоматически определяет нужный вариант метода по его параметрам, которые указаны при
вызове.

[К оглавлению](#OOP)

## 19. Можно ли изменить тип возвращаемых данных при перегрузке метода?

Можно, если списки аргументов отличаются, иначе JVM не поймет какой метод ей нужно вызвать. Т.е. если меняем тип
возвращаемого значения, то мы также должны изменить список аргументов перегружаемого метода.

[К оглавлению](#OOP)

## 20. Что такое множественное наследование? Как его можно реализовать в Java.

Множественное наследование - это наследование класса от нескольких суперклассов одновременно. В Java запрещено
множественное наследование главным образом из-за ромбовидной проблемы. Возникает неоднозначность: если метод класса D
вызывает метод класса А (и этот метод не переопределён в классе D), а классы B и C по своему переопределили этот метод,
то от какого класса его наследовать? От B или C? В Java множественное наследование поддерживают интерфейсы. Если есть
необходимость использовать методы из двух разных классов, то можно воспользоваться композицией. Для этого в третьем
классе нужно создать два необходимых объекта, добавить методы, которые обращаются к нужным методам этих объектов. И
наследоваться от этого класса.

Композиция - отношения "часть целое" между двумя объектами, когда один из них включает в себя другой. Особенность этого
отношения заключается в том, что компонент может существовать только как часть контейнера. Например: Университет состоит
из кафедр.

Агрегация - менее строгий вариант композиции, когда один объект имеет ссылку на другой объект. Здесь контейнер не
управляет жизненным циклом компонента. Компонент может существовать отдельно от контейнера. Например: кафедра состоит из
профессоров.

Ассоциация - когда объект использует другой объект, либо зависит от него. Возможна двухсторонняя ассоциация между
объектами. Например: профессор взаимодействует со студентами.

[К оглавлению](#OOP)

## 21. Что такое полиморфизм? Приведите примеры из реальной жизни.

Полиморфизм описывают выражением - один интерфейс, множество реализаций. Полиморфизм принцип ООП, позволяющий
использовать один и тот же интерфейс для общего класса действий. Это возможность работать с несколькими типами, как
будто это один и тот же тип, однако поведение каждого типа будет уникальным в зависимости от его реализации. В этом и
есть одно из самых ярких проявлений полиморфизма – вместо того, чтобы слева от знака присваивания ставить конкретный
класс, мы используем интерфейс и, следовательно, можем использовать методы, определенные в нем, а также всех вышестоящих
по иерархии интерфейсов. Полиморфизм
позволяет достигнуть взаимозаменяемости, т.е. часть программы не имеет жесткой связи и ее можно заменить на другую
программу. Например: собачье обоняние - полиморфное свойство. Если собака учует запах кота - она залает и погонится за
ним. Если собака учует запах своего корма, у нее начнется слюноотделение и она побежит к своей миске. В обоих случаях
действует одно и тоже-чувство обоняния, отличие в том, что именно издает запах, т.е. в типе данных воздействующих на нос
собаки.

[К оглавлению](#OOP)

## 22. Что такое инкапсуляция?

Инкапсуляция — это принцип ООП, при котором поля класса скрыты от внешнего мира. Доступ к полям осуществляется только
через методы класса. Это позволяет защитить поля от неправильного использования и обеспечивает гибкость в изменении
реализации класса без необходимости изменения клиентского кода.

[К оглавлению](#OOP)

## 23. Как реализована инкапсуляция в Java?

В Java инкапсуляция реализуется с помощью модификаторов доступа (public, private, protected), и специальными методами
для их изменения(гетеры и сетеры) Поля объявляются с
модификатором private, а методы, осуществляющие доступ к этим полям, — public.

- public - доступен везде в программе.
- private - доступен внутри класса.
- default - доступен внутри пакета.
- protected - доступен внутри пакета и в наследниках.

[К оглавлению](#OOP)

## 24. Можно ли применить модификаторы доступа к конструкторам?

Да, модификаторы доступа можно применить к:

- классу.
- конструктору.
- методу.
- поля класса.

Модификаторы доступа нельзя применить только к локальным переменным.

[К оглавлению](#OOP)

## 25. Что такое интерфейс?

Это набор правил, которые должны быть реализованны в классе. Интерфейс содержит объявление методов, но не содержит
реализации этих методов. Интерфейс определяет, что должен делать класс, но не знает как. Интерфейс позволяет создавать
общий тип данных для различных объектов, т.е. использование интерфейса гарантирует наличие определенного метода у
объекта. При реализации интерфейса класс должен реализовывать все его методы, иначе он должен быть помечен,
как `abstract`

[К оглавлению](#OOP)

## 26. Перечислите элементы, которые может содержать интерфейс.

1) В интерфейсе можно объявить поля, которые должны быть проинициализированы сразу при объявлении. Поля должны быть
   только константами, т.е. `public static final`
2) Абстрактные методы. Начиная с java 8 можно включать в интерфейс статические или дефолтные методы. Начиная с java 9
   еще и приватные.

- Статические методы - принадлежат только интерфейсу в котором объявлены, и не наследуются ни классами реализующими
  интерфейс, ни интерфейсами - наследниками. Такие методы можно применять, когда нужно сохранить какие-либо данные на
  уровне интерфейса, а уже эти данные могут быть использованы любым классом реализацией.
- Дефолтные методы - отличаются от статических тем, что он будет унаследован классом, который реализует данный
  интерфейс. При этом класс может как переопределить данный метод, так и не переопределять и воспользоваться реализацией
  по умолчанию. Дефолтные методы удобно использовать, если в классах, имплементирующих один и тот же интерфейс, должен
  быть объявлен метод с одинаковой реализацией. Дефолтные методы наследуются производными интерфейсами от базовых. При
  использовании дефолтных методов может возникнуть неясность кода, когда компилятор не будет понимать метод какого из
  интерфейсов нужно вызвать, проблему можно решить переопределив эти методы.
- Приватные методы - обозначаются ключевым словом private. Они могут быть как статическими, так и нестатическими. Эти
  методы используются в интерфейсах для того, чтобы вынести какую то логику из публичных статических или дефолтных
  методов, либо для предотвращения дублирования кода. В приватный метод можно убрать все детали реализации, чтобы
  уменьшить пользовательский код и упростить его читаемость, также в private методы нужно убирать задвоившийся код.

3) Интерфейсы могут содержать вложенные классы и интерфейсы. Вложенные в класс интерфейсы - это еще один уровень
   изоляции и организации кода. Такая схема чаще используется, когда нужно привязать интерфейс к классу, а не к пакету,
   либо этот интерфейс нужен только внутри этого класса для определенных целей. Обращение ко вложенным интерфейсам идет
   так же, как и к классам - через его класс и точку

4) Обобщенные типы (generics) используются вместо указания конкретного типа, тем самым интерфейс может работать с
   разными типами данных, то есть отпадает необходимость писать несколько одинаковых реализаций, отличающихся только
   типом данных.

5) В интерфейсе можно объявить Enum (перечисление).

Интерфейс не содержит конструктора, т.к. интерфейс это абсолютная абстракция, т.е. вся реализация возложены на классы
реализующие интерфейс.

[К оглавлению](#OOP)

## 27. Можно ли создать объект интерфейса? Если да, то как?

По причине отсутствия конструктора создать экземпляр интерфейса невозможно.

[К оглавлению](#OOP)

## 28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?

Начиная с Java 8 мы можем включать в интерфейсы методы с реализацией - статические или дефолтные, а начиная с Java 9 еще
и приватные.

[К оглавлению](#OOP)

## 29. Что такое абстракция?

Это выделение значимой информации и исключение из рассмотрения незначимой. С помощью принципа абстракции программа
разбивается на объекты. Информация в программе обрабатывается в виде цепочки действий между отдельными объектами.
Главное достоинство абстракции состоит в том, что она позволяет отделить реализацию объектов от их описания. Например:
автомобиль. Мы его представляем не в виде тысяч отдельных деталей, а виде объекта имеющего свое особое поведение. Эта
абстракция позволяет нам не задумываться о сложности внутреннего устройства автомобиля когда мы им пользуемся.

[К оглавлению](#OOP)

## 30. Что такое абстрактный класс?

Абстрактный класс похож на обычный, разница в том, что абстрактный класс это заготовка под будущую реализацию. В нем
помимо обычных можно определить абстрактные методы, тем самым задается некое поведение, но реализация перекладывается на
класс наследник. От обычных классов он отличается тем, что нельзя создать объект такого класса. Абстрактный класс нужен
для того, что бы от него могли наследоваться потомки - обычные классы, объекты которых уже можно создавать. Абстрактный
класс представляет собой отношение is - a (когда объект Б является подтипом объекта А)

[К оглавлению](#OOP)

## 31. Сколько абстрактных методов должен и может содержать абстрактный класс?

Не ограниченно, но если много абстрактных методов это, может быть, сигналом о том, что мой класс слишком сложен и его
следует разделить на несколько более простых классов.

[К оглавлению](#OOP)

## 32. Может ли абстрактный класс содержать обычные методы?

Да. Такие методы должны быть обязательно реализованны в подклассах, иначе класс так же становится абстрактным.

[К оглавлению](#OOP)

## 33. Сколько объектов абстрактного класса можно создать в программе?

Создание объекта абстрактного класса невозможно потому что:

- Это нарушает принцип инкапсуляции - мы не можем создать экземпляр чего-то, что не полностью определено.
- Нет смысла создавать объекты абстрактного класса, так как они не могут использоваться самостоятельно, а только как
  основа для создания объектов конкретных дочерних классов.

[К оглавлению](#OOP)

## 34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?

Если наследник этого не делает, то он так же становится абстрактным. Если класс должен обязательно иметь реализацию всех
абстрактных методов его следует пометить как `final`

[К оглавлению](#OOP)

## 35. Чем отличается интерфейс от абстрактного класса?

1) У интерфейса нет конструктора.
2) Класс может одновременно реализовывать несколько интерфейсов, наследоваться только от одного.
3) Абстрактный класс - это класс, у которого не реализован один и более методов. У интерфейса методы объявляются без
   реализации(кроме default, private, static), а так же нет нестатических переменных.
4) Абстрактные классы используются тогда, когда есть отношение IS-A, т.е. класс наследник расширяет базовый
   абстрактный класс. Интерфейсы могут быть реализованны в несвязанных друг с другом классах.
5) Любой интерфейс - абстрактный класс, но не наоборот.

Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все
подклассы схожи между собой в части реализации, унаследованной от абстрактного класса и отличаются лишь в части
собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения
однотипных иерархий. В этом случае наследование от абстрактного класса реализующего поведение объекта по умолчанию
может быть полезно, т.к. позволяет избежать дублирования кода. Во всех остальных случаях лучше использовать интерфейсы,
т.к. наследуясь от абстрактного класс растворяет собственную индивидуальность, а реализуя интерфейсы - расширяет свою
функциональность.

[К оглавлению](#OOP)

## 36. Что такое вложенные классы? Зачем они нужны?

Это классы, которые определены внутри других классов. Они нужны для того, что бы добавить дополнительную структуру и
организацию кода, а так же для инкапсуляции методов и данных, которые относятся к определенному контексту. Вложенные
классы предоставляют возможность использовать поля внешнего класса без необходимости создания экземпляра внешнего
класса. Это делает код более кратким и читаемым, т.к. не нужно создавать дополнительные переменные или методы для
доступа к полям внешнего класса. С помощью вложенных классов можно создать приватные классы, которые могут быть
использованы только в контексте внешнего класса, что обеспечивает дополнительную безопасность и защиту данных.

[К оглавлению](#OOP)

## 37. Какие типы вложенных классов существуют в Java?

Статические вложенные классы и вложенные классы. Вложенные классы бывают - локальными, анонимными, внутренними.

Рекомендации к применению вложенных классов:

- Статический. Если ссылка на внешний класс не требуется.
- Внутренний. Если вложенный класс должен быть виден за пределами одного метода, или он слишком большой для того, что бы
  его можно было удобно разместить в границах одного метода, и если каждому экземпляру такого класса необходима ссылка
  на включающий его экземпляр.
- Локальный. Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого класса только в
  этом методе.
- Анонимный. Если применение класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий
  этот класс.

[К оглавлению](#OOP)

## 38. Что такое внутренний класс? Когда он применяется?

Внутренний класс - это не статический вложенный класс. Его применяют, когда нужно написать вспомогательный код для
другого класса. Так же внутренний класс скрывает переменные и методы от остальной части программы, что является хорошим
способом ограничения области их видимости. Внутренний класс так же применяют когда необходимо сохранить связь между
объектом внутреннего класса и объектом внешнего класса. Обычно внутренний класс наследуется от класса или реализует
интерфейс, а код внутри класса манипулирует объектом внешнего класса, в котором он был создан, поэтому можно считать
внутренний класс окном во внешний класс. Каждый внутренний класс способен независимо наследовать определенную
реализацию. Таким образом внутренний класс не ограничен при наследовании в ситуациях, где внешний класс уже наследует
реализацию. Внутренний класс не может существовать сам по себе, поэтому внутренний класс неявно имеет ссылку на объект
внешнего класса. Внутренний класс ассоциируется не с внешним классом, а с экземпляром внешнего класса. Внутренний класс
может обратиться к любому полю внешнего класса напрямую. В случае, если у вложенного класса уже существует поле с таким
же литералом, то обращаться к такому полю следует через ссылку на его экземпляр.

Например: представим класс авто с полями марка и модель, а так же с двумя внутренними классами: тормоза и трансмиссия, в
которых определены методы ускорения и торможения. В данном случает трансмиссия и тормоза это внутренние системы авто. В
контексте авто они не могут существовать отдельно от него.

[К оглавлению](#OOP)

## 39. Что такое статический вложенный класс? Когда он применяется?

Статический вложенный класс это вложенный класс в объявлении которого есть ключевое слово `static`. Как и другие
статические поля, они принадлежат внешнему классу, а не экземпляру класса. Статическим полям не требуется ссылка на
какой-либо объект. Статический вложенный класс не привязан к объекту, объект статического вложенного класса не хранит в
себе ссылку на внешний класс. Статический вложенный класс можно использовать когда прямая связь между вложенным и
внешним классами не требуется. При объявлении статического вложенного класса можно указать любой модификатор доступа.
Статический вложенный класс имеет доступ только к статическим полям во внешнем классе(в том числе к приватным). К
нестатическим полям и методам внешнего класса доступ можно получить только через ссылку на экземпляр внешнего класса.
Сам класс виден окружающим согласно установленному модификатору доступа.

[К оглавлению](#OOP)

## 40. Сколько объектов статического вложенного класса можно создать в программе?

Сколько угодно, это не статическая переменная, которая создается одна на все программу.

[К оглавлению](#OOP)

## 41. Что такое локальный класс? Когда он применяется?

Это разновидность внутреннего класса, в котором класс объявляется в другом классе внутри какого либо блока кода. Его
можно объявить везде, где возможно объявить локальную переменную, он обладает такой же областью видимости. У локальных
классов есть имя, их можно использовать неоднократно.

Особенности локального класса:

- Время жизни локального класса ограниченно блоком кода, в котором он находится, либо пока в программе остаются рабочие
  ссылки на этот класс.
- Если локальный класс находится внутри статического метода, он имеет доступ только к статическим переменным внешнего
  класса.
- Создать экземпляр локального класса можно только после окончания блока кода самого локального класса.
- За пределами внешнего класса локальные переменные недоступны, но экземпляры локальных методов можно использовать, как
  и обычные классы, используя их в качестве аргументов или возвращаемых значений.
- Имеют доступ к полям и методам внешнего класса.
- до java 16 локальные классы не могли содержать в себе статические объявления, допустимы только переменные константы. В
  Java 16 произошло обновление начиная с которого все виды внутренних классов поддерживают статические объявления, что
  бы иметь возможность объявлять в себе record, enum и локальные интерфейсы, которые неявно являются статическими при
  объявлении их во внутреннем классе.

[К оглавлению](#OOP)

## 42. Что такое анонимный класс? Когда он применяется?

Это локальный класс без имени. Анонимным классом следует пользоваться, если нужен локальный класс для одноразового
использования. Создание экземпляра анонимного класса происходит одновременно с его объявлением(между скобками и точкой с
запятой, заключенный в фигурные скобки). В фигурных скобках находится полноценный класс, просто у него нет имени.
Анонимный класс может обращаться к переменным и методам внешнего класса, в том числе статическим и приватным. Цель
анонимного класса - это короткая запись класса для выполнения конкретной разовой задачи. У анонимного класса нет
конструктора. Анонимные классы могут наследовать другие классы, реализовывать интерфейсы. Внутри анонимного класса можно
переопределять методы родителя и писать свои методы. Анонимные классы следует использовать когда уже есть тип, который
описывает этот класс(либо его родителей), и задача будет выполняться один раз за всю работу программы(т.е. когда нам
нужен всего один экземпляр это класса). Анонимные классы желательно применять к компактным задачам, что бы не ухудшать
чтение кода.

[К оглавлению](#OOP)

## 43. Сколько объектов анонимного класса можно создать в программе?

Мы можем создать любое количество объектов анонимного класса, но следует помнить, что каждый анонимный класс создает
новый экземпляр внутреннего класса, что может привести к увеличению потребления памяти.

[К оглавлению](#OOP)

## 44. Что такое исключения? Какие типы исключительных ситуаций бывают?

Исключение - это ошибка(в java является объектом) возникающая во время выполнения программы. В случае возникновения
исключения в Java приложение завершается в аварийном режиме, что не является рекомендованным, и, как следствие, подобные
случаю требуют обработку. Исключения делятся на несколько классов, но все они имеют общего предка - класс `Throwable`,
потомками которого являются классы `Exception` и `Error`

`Error`  ошибки представляют собой серьезные проблемы которые не следует обрабатывать,
поскольку они связанны с проблемами уровня JVM. Например: закончилась память, доступная JVM(StackOverflow
error).

`Exceptions` исключения являются результатом проблем в программе, которые в принципе решаемы, предсказуемы и последствия
которых возможно устранить внутри программы. Исключения делятся на проверяемые и не проверяемые.

- Проверяемые исключения. Проверяются во время компиляции программы и если такие исключения не обработать - программа не
  скомпилируется. Для обработки исключения используется блок `try-catch` и ключевое слово `throws` после сигнатуры
  метода. К таким исключениям относятся: готовые исключения подклассов IOException, SQLException, а так же все
  пользовательские исключения, которые наследуются от класса `Exception`.
- Не проверяемые исключения. Проверяются во время запуска программы, т.е. если их не обработать с помощью
  конструкции `try-catch`, то код скомпилируется без проблем. К непроверяемым исключениям относятся все наследники
  класса `RunTimeException`

[К оглавлению](#OOP)

## 45. Назовите основные методы класса Object?

public native int hashCode() — возвращает хеш-код объекта.

public boolean equals(Object obj) — сравнивает объекты.

public String toString() — возвращает строковое представление объекта.

public final native Class getClass() — возвращает в рантайме класс данного объекта.

protected native Object clone() throws CloneNotSupportedException — клонирование объекта

public final native void notify() — просыпается один поток, который ждет на "мониторе" данного объекта.

public final native void notifyAll() — просыпаются все потоки, которые ждут на "мониторе" данного объекта.

public final native void wait(long timeout) throws InterruptedException — поток переходит в режим ожидания в течение
указанного времени.

public final void wait() throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет
notify() или notifyAll() методы для этого объекта.

public final void wait(long timeout, int nanos) throws InterruptedException — приводит данный поток в ожидание, пока
другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.

protected void finalize() throws Throwable — вызывается сборщиком мусора, когда garbage collector определил, что ссылок
на объект больше нет.

Модификатор native сигнализирует о том, что метод реализован в платформ-зависимом коде, часто на языке С.

[К оглавлению](#OOP)

## 46. Что такое шаблоны проектирования?

Это часто встречаемое решение определенной проблемы при проектировании архитектуры программ. В отличие от готовых
функций и библиотек, паттерн нельзя скопировать в программу. Паттерн представляет собой не конкретный код, а общую
концепцию или пример решений той или иной проблемы, которое нужно будет подстроить под нужды вашей программы. Паттерны
отличаются предназначением:

- Порождающие - беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
- Структурные - показывают различные способы построения связей между объектами.
- Поведенческие - заботятся об эффективной коммуникации между объектами.

[К оглавлению](#OOP)

## 47. Объясните шаблон - декоратор. Придумайте пример, не относящийся к технике.

Структурный паттерн проектирования, который позволяет добавлять объектам новую функциональность, оборачивая их в
полезные обёртки. Целевой объект помещается в другой объект - обёртку, который запускает базовое поведение обёрнутого
объекта, а затем добавляет к результату, что-то своё. Оба объекта имеют общий интерфейс, поэтому для пользователя нет
никакой разницы с каким объектом работать - чистым или обёрнутым. Можно использовать несколько обёрток одновременно -
результат будет иметь объединенное поведение всех обёрток сразу. Применяя декоратор можно менять состояние объекта.

Плюс: большая гибкость, чем у наследования.

Минус: труднее конфигурировать многократно обёрнутые объекты.

Пример: любая одежда - аналог декоратора. Применяя декоратор, вы не меняете первоначальный класс и не создаете дочерних
классов, так и с одеждой - надевая свитер вы не перестаете быть собой, но получаете новое свойство защиту от холода.
Можно пойти еще дальше и надеть сверху еще один декоратор - плащ, что бы обеспечить себе защиту еще и от дождя.

[К оглавлению](#OOP)

## 48. Объясните шаблон - стратегия. Придумайте пример, не относящийся к технике.

Является поведенческим шаблоном проектирования, который позволяет решать, какой план действий должна предпринять
программа, основываясь на определенном контексте при выполнении. Мы закладываем различные алгоритмы внутри других
классов и решаем в ходе выполнения с какой стратегией следует работать.

Плюс: изолирует данные и код алгоритма от остальных классов. Уход от наследования к делегированию(это когда часть работы
класс перекладывает на другие классы).

Минус: усложняет программу за счет введения дополнительных классов. Клиент должен знать в чем разница между стратегиями,
что бы выбрать подходящую.

Пример: нужно добраться до вокзала. Можно ехать на авто, такси, велосипеде. Вид транспорта - стратегия, я выбираю
конкретную стратегию в зависимости от контекста(наличия денег или время до отправления поезда)

[К оглавлению](#OOP)

## 49. Объясните шаблон - синглтон. Придумайте пример, не относящийся к технике.

Одиночка - порождающий паттерн, который гарантирует, что у класса есть только один экземпляр и предоставляет к нему
глобальную точку доступа. Конструктор помечается `private`, а для создания нового объекта используется специальный
метод `getInstance()`. Он либо создает новый объект, либо отдает существующий объект, если он уже был создан. Синглтон
применяют в проектах, где используются внешние ресурсы: файловая система, база данных, связь с другими приложениями.

Плюс: можно не создавать множество объектов для ресурсоёмких задач, а пользоваться одним.

Минус: нарушает принцип единой ответственности, т.к. его могут использовать множество объектов.

Пример: Правительство государства. В государстве может быть только одно официальное правительство. Вне зависимости от
того, кто в нем заседает, оно имеет глобальную точку доступа - правительство страны Венгрия.

[К оглавлению](#OOP)

## 50. Объясните шаблон - фабричный метод. Придумайте пример, не относящийся к технике.

Порождающий шаблон, в котором подклассы имплементируют общий интерфейс с методом для создания объектов. Переопределенный
метод в каждом наследнике возвращает нужный вариант объекта. Объекты все равно будут создаваться при помощи
оператора `new`, но делать это будет фабричный метод. Таким образом можно переопределять фабричный метод в подклассе,
что бы изменить тип создаваемого объекта. Что бы эта система заработала, все возвращаемые объекты должны иметь один
общий интерфейс. Подклассы могут создавать объекты различных классов следующих одному тому же интерфейсу.

Плюс: получаем лаконичный код, в котором явно видна логика.

Минус: может привести к созданию больших параллельных иерархий классов, т.к. для каждого класса продукта надо создать
свой подкласс создателя.

Пример: наилучшей ситуацией для использования шаблона фабричный метод является наличие нескольких разных вариантов
одного объекта. Класс кнопка. У нее есть разные варианты: кнопка изображения, кнопка ввода и флэш - кнопка. В
зависимости от места может потребоваться создать разные кнопки.

[К оглавлению](#OOP)

## 51. Что такое enum? Когда можно его применять?

Enum - это класс-перечисление. Перечисление - это набор констант, связанных между собой по смыслу. Константы здесь - это
статические объекты, создающиеся в единственном экземпляре. Обычно перечисление используют для работы со значениями,
которые никогда не меняются. Например, дни недели, времена года, карточные масти, записи полей шахматной доски.
Перечисление можно использовать и для групп констант другого вида. Например, для перечисления в программе статусов
работы в автосервисе ("Принят на сервис", "В работе", "Ожидание запчастей", "Готов" и т.д.). Такие статусы никогда не
меняются и имеют логическую связь между собой. Enum создается как обычный класс в Java, только нужно выбрать
соответствующее значение enum. Перечисление может объявляться отдельно, а может быть объявлено в другом классе в виде
внутреннего класса. Если enum вложен в другой класс, он может быть как public, так и private. Если же enum не является
внутренним классом, то он может иметь только модификатор public. Перечисление (enum) наследуется от `java.lang.Enum`,
поэтому он не может наследовать другие классы. Перечисление может реализовывать интерфейсы. Перечисление может содержать
поля, методы и конструкторы. Конструктор `enum` неявно имеет модификатор `private`, поэтому создать объект перечисления
мы
можем только внутри него самого. Каждый из экземпляров перечисления создаётся только при первом обращении к нему. Каждое
значение (константа) нашего перечисления - это объект анонимного класса. Отсюда следует, что перечисление - это список
неизменяемых готовых объектов, которыми можно пользоваться.

[К оглавлению](#OOP)

## 52. Что такое record? Когда можно его применять?

Record дает возможность записать стандартную модель данных в виде одной строки, то есть с помощью record можно
избавиться от шаблонного кода, который приходится писать в каждой модели данных.
Поля, переданные в параметрах, являются private и final по умолчанию.
Код имеет канонический конструктор, параметры которого - это все поля данного класса.
Доступ к полям осуществляется через методы типа имя_поля(). Тот же геттер, только без слова get в имени метода.
Методов типа set класс record не имеет, так как все поля объявлены как final, поэтому record является неизменяемым.
Определены методы equals() и hashcode(), включающие все поля класса.
Определен шаблонный метод toString() для вывода полей класса на печать.
Если всё же нужно изменить поле, то потребуется создать новый объект record, скопировать в него значения полей,
которые не менялись, и указать новое значение в поле, которое нужно изменить. Есть небольшая разница в каком виде
выводится объект на печать, потому что в record для вывода объекта на печать используется StringJoiner, а в обычном
классе мы используем стандартную реализацию toString(). Точно так же можно переопределять в record свои реализации
конструкторов и методов, если это необходимо. В record можно добавлять только статические переменные (как константы,
так и обычные статические переменные). В record можно добавлять свои методы, как нестатические, так и статические.
Record является final, поэтому наследование этого класса невозможно. Сам record наследовать другие классы не может,
так он унаследован от `java.lang.Record`, но record может реализовывать интерфейсы. Record удобно применять,
когда
у модели могут добавляться или удаляться поля. Достаточно просто вписать новое поле в запись record и в класс
автоматически будут внесены изменения. В случае же с обычным классом нужно будет вручную вписывать поле в модель, менять
конструктор, методы equals(), hashcode(), toString(), добавлять или удалять геттеры.

Конструктор record:

- По умолчанию record имеет канонический конструктор - это конструктор, принимающий все поля класса в качестве
  параметров. Конструктор по умолчанию при объявлении явного канонического конструктора создан не будет.
- Если нам нужен конструктор с какой-то логикой помимо обычной инициализации полей, можно создать компактный
  конструктор. Данный конструктор называется компактным, так как в нем поля не инициализируются явным образом.
  Инициализация проходит неявно перед выполнением команд, находящихся внутри конструктора. Данная инициализация
  автоматически будет проходить в любом переопределенном конструкторе. Это гарантирует, что все поля будут
  инициализированы.
- Если в record уже объявлен компактный конструктор, то явно объявить еще и канонический конструктор в этом классе
  невозможно, так как при объявлении компактного конструктора автоматически создается конструктор по умолчанию, чтобы
  провести инициализацию всех полей перед выполнением команд компактного конструктора, поэтому нельзя еще раз
  объявить в классе такой же конструктор с теми же параметрами.

[К оглавлению](#OOP)

## 53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?

String - это неизменяемый класс. После создания объект этого класса изменить нельзя. Строка - это неизменяемая
последовательность символов. При любых операциях изменения строки типа String будет создан новый объект String с
результирующим содержимым. Конкатенация(объединение строк) при помощи оператора `+` является плохим решением с точки
зрения производительности программы, т.к. каждые объекты строк будут создаваться отдельно и храниться в памяти. Для
решения проблемы разработали классы StringBuilder, StringJoiner, StringBuffer.

StringBuilder - это класс, являющийся
изменяемой последовательностью символов. Он дает возможность создать объект класса StringBuilder, и добавлять в него
другие строки без создания новых объектов. StringBuilder спроектирован на основе динамического массива(когда
заканчивается место для записи в существующем массиве символов создается новый массив в 2 раза большей длинны и в него
копируется все содержимое старого массива. Теперь мы не создаем новый объект при каждом проходе в цикле, а просто
добавляем новую строку к уже имеющейся). Благодаря этой системе значительно уменьшается количество операций по созданию
новых объектов, такая программа работает быстрее.

StringJoiner - класс для составления строк. StringJoiner базируется на StringBuilder и имеет удобную
возможность соединять строки через разделитель, а также добавлять префикс и/или суффикс к результирующей строке.
StringJoiner и StringBuilder имеют переопределенные методы toString(). Классы StringBuilder и StringJoiner не
синхронизированы.

StringBuffer - это аналог StringBuilder, только с синхронизированными методами для работы в многопоточном окружении.

Еще способы: Когда нам нужно объединить 2 и более строки с каким-либо разделителем, например, пробелом, то можно
использовать метод join() класса String.

String.concat() - удобно пользоваться, если у нас уже есть готовые строки, которые мы просто хотим объединить и получит
результат. Метод
concat() класса String возвращает объект String. Метод concat() можно объединять в цепочку, в результате работы которой
будет возвращена новая строка без накладных расходов в виде создания промежуточных строк.

[К оглавлению](#OOP)

## 54. Чем отличаются StringBuffer и StringBuilder?

StringBuilder и StringJoiner - не синхронизированы. Они будут некорректно работать в многопоточной среде. StringBuffer -
аналог StringBuilder, только с синхронизированными методами для работы в многопоточной среде.

[К оглавлению](#OOP)

## 55. Каким образом производится экранирование символов и зачем это нужно?

Экранирование символов осуществляется с помощью обратного слэша \. Необходимо для решения проблемы невозможности
вывода символов в тексте таким, какой он есть.

[К оглавлению](#OOP)

## 56. Что такое управляющие последовательности?

Комбинация в виде обратного слэша и экранируемого им символа называется управляющей последовательностью (
escape-последовательность). Все управляющие последовательности подсвечиваются в IDEA синим цветом. Это означает, что эти
символы расцениваются как единый символ. В Java существует 8 видов управляющих последовательностей:

- \\' - Добавляет одинарную кавычку. Аналогично выводу двойной кавычки, выводит одиночную кавычку. Имеет смысл при
  выводе символа одинарной кавычки в одинарных кавычках (аналогично двойной кавычке среди двойных).
- \\" - Добавляет двойную кавычку
- \\ - Добавляет обратный слэш
- \r - Возврат каретки в начало строки. Возвращает каретку в начало строки, "обнуляя" её. Если в строке были данные, они
  пропадут.
- \n - Перевод каретки на новую строку.
- \f - Прогон страницы. Переводит документ на новую страницу. Неиспользуемый спецсимвол.
- \b - Возврат каретки на одну позицию назад. Работает как BackSpace - стирает один символ позади текущего положения
  каретки.

[К оглавлению](#OOP)

## 57. Зачем нужно форматирование данных? Метод format()

За создание форматированного текстового вывода отвечает класс `java.util.Formatter`. Метод format() этого класса
позволяет
выводить различные данные - строки, числа, даты, время в желаемом виде, т.е. преобразует данные в тот формат, который
нам нужен.

Метод format() класса String внутри он создает объект класса Formatter, вызывает у него метод format() с заданными нами
аргументами, и после возвращает строковое представление объекта Formatter. Метод format() класса Formatter получает
данные и преобразует их в определенный строковый формат. Отформатированные данные возвращаются в виде объекта типа
Formatter, который выводится в строковом представлении в методе format() класса String. Методы format() специально
определены в классе String и еще, например, в классах PrintStream и PrintWriter, т.е. в классах, которые работают с
выводом строк, чтобы не нужно было отдельно работать с классом Formatter - это удобно и получается меньше кода. А в
классах PrintStream и PrintWriter определён еще и метод printf(), который результат форматирования сразу выводит в
консоль аналогично методам print() или println().

Различия методов format() и printf():
Метод format() выполняет форматирование и возвращает новую строку. Её можно сохранить и использовать в дальнейшем. Метод
printf() выполняет форматирование и выводит данные в консоль без сохранения.

[К оглавлению](#OOP)

## 58. Что такое varargs? В каких случаях стоит его применять?

Это механизм, который позволяет передавать переменное количество аргументов в метод. Это может быть полезно, когда нужно
создать метод, который может принимать любое количество аргументов определенного типа, такой метод называется методом с
аргументами произвольной длинны. Нужно помнить что использование varargs может привести к риску столкнуться с
неоднозначностью и вопросом понимания какой из перегруженных методов вызывается, а так же к снижению производительности
из-за дополнительных затрат на создание массива аргументов. Поэтому их стоит использовать с осторожностью и только там,
где это необходимо.

[К оглавлению](#OOP)

## 59. В каких случаях может возникнуть неоднозначность при работе с varargs?

Неоднозначность при работе с Varargs в Java возникает, когда сигнатура метода содержит переменное количество
аргументов (varargs), и есть несколько перегруженных версий этого метода с различным числом аргументов. В данном случае,
компилятор не может определить, какую версию метода вызвать, так как обе версии принимают переменное число аргументов, а
сигнатуры методов идентичны. Чтобы устранить эту неоднозначность, можно использовать явное приведение типов для
аргументов.

Так же если я перегружаю метод с разными типами. Неоднозначность проявится, когда попробую выполнить метод не указывая в
нем параметров. Не имея параметров, компилятор не сможет понять, какой из вариантов метода ему выбрать, т.к. оба будут
подходить. Такую неоднозначность можно разрешить путем отказа от перегрузки и объявления такого же метода, но с другим
именем. В целом появление неоднозначности может говорить о неидеальном решении поставленной задачи.

[К оглавлению](#OOP)

## 60. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?

Форматирование производится по шаблону - в метод format() передаётся строка с указанными местами для подстановки
аргументов, а также сами значения, которые необходимо вставить.
Форматирование применяется в шаблонных текстах или строках, где требуется подстановка в какие-то места шаблона различных
значений, принимаемых в виде параметров. В первый параметр метода format() передаётся строка с указанным спецификатором
%s, это некий шаблон. Спецификатор %s (любой тип данных) здесь означает тип аргумента, который будет передан на
форматирование.

- С помощью спецификатора d% мы передаём на форматирование целое число.
- %b. Любой переданный аргумент будет
  превращён в true.
- %c. Задаёт любой символ из таблицы Юникод. 
- %t. Преобразует дату и время. Применяется только с дополнительными флагами. С помощью различных флагов можно выводить
  дату и время в
  различном виде, а также, например, дни недели или месяцы.
- %f. Задаёт число с плавающей точкой.
С помощью них можно указывать позицию аргумента в списке, устанавливать специальные флаги, минимальное количество
  выводимых символов и ограничение количества символов. `%[индекс_аргумента$][флаг(и)][ширина][.точность]спецификатор` -
  запись называется инструкцией. С помощью индекса аргумента можно указать позицию в списке аргументов (в виде целого
  числа). Флаги - это отдельные символы для
  изменения результата форматирования. Например, флаг "+" добавит знак "+" к
  получившемуся результату, а флаг "," выведет результат с разделителем между разрядами (запятая или пробел, зависит от
  локализации). Ширина определяет количество выводимых символов. Задаётся целым положительным числом. Если перед ним
  поставить 0, то
  если общее количество символов строки вывода будет менее этого значения, разница будет заполнена нулями. Точность мы
  уже разобрали выше. Через указание точки и целого числа можно задать выводимое после точки количество
  символов.

[К оглавлению](#OOP)